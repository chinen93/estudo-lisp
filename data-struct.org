#+TITLE:        Data Struct Study
#+AUTHOR:       Pedro Chinen
#+EMAIL:        ph.u.chinen@gmail.com
#+DATE-CREATED: [2018-02-09 Fri]
#+DATE-UPDATED: [2018-02-28 Wed]

* Orientação a Objetos
:PROPERTIES:
:ID:       34c8e45a-972a-4348-abe8-c0cd75fff43a
:END:

https://ericabrahamsen.net/tech/2016/feb/bbdb-eieio-object-oriented-elisp.html

* Listas
:PROPERTIES:
:ID:       38a6ba3e-669c-47ec-b294-3eb5c12c7e39
:END:

https://www.gnu.org/software/emacs/manual/html_node/cl/Lists.html#Lists
https://www.gnu.org/software/emacs/manual/html_node/elisp/Lists.html#Lists

Uma lista é uma sequência de zero ou mais elementos (estes elementos podem ser qualquer objeto LISP).

Uma lista nada mais é do que uma "cons cell", que é uma representação de um par ordenado. Uma lista é um conjunto de "cons cells" no qual o primeiro elemento do par é o elemento da lista e o segundo elemento é a proxima "cons cell".

A ultima "cons cell" da lista tem como segundo elemento o valor "nil" indicando que a lista terminou.

** Construção
:PROPERTIES:
:ID:       e59c9a25-d93d-4804-b497-a319f0def929
:END:

Muitas funções criam listas, uma vez que listas é a principal estrutura de dados em elisp. No entanto existe um função em particular que pe a principal na criação de listas. A função "cons"

*cons object1 object2*, funciona criando uma lista na qual o primeiro elemento é object1 e seu segundo object2. Esta função é normalmente utilizada para colocar um elemento na frente de uma lista.

*list $rest objects* é uma outra forma de criar listas. Dessa forma todos os elementos em objects serão os elementos da lista, não limitado apenas por 2 objetos como em "cons".

** Acessar elementos
:PROPERTIES:
:ID:       c58b5ea1-a9b2-495a-8064-2397223c6a78
:END:

*** Primeiro (CAR CONS-CELL)
:PROPERTIES:
:ID:       a22f46ed-5a0e-467f-9bec-526d175cf58d
:END:

Retorna o elemento que esta no primeiro par de CONS-CELL.

Como uma lista é um conjunto de cons cells se uma lista for passada como parametro o primeiro elemento da lista será retornado.

#+begin_src emacs-lisp
  (car '(1 2 3 4))
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
  (car (cons 1 2))
#+end_src

#+RESULTS:
: 1

*** Resto (CDR CONS-CELL)
:PROPERTIES:
:ID:       d9e4321f-1f01-40a2-9920-cbde291e1156
:END:

Retorna o elemento que esta no segundo par de CONS-CELL.

Como uma lista é um conjunto de cons cells se uma lista é passada como parametro o segundo elemento em diante será retornado.

#+begin_src emacs-lisp
  (cdr '(1 2 3 4))
#+end_src

#+RESULTS:
| 2 | 3 | 4 |

#+begin_src emacs-lisp
  (cdr (cons 1 2))
#+end_src

#+RESULTS:
: 2

*** N-ésimo elemento (NTH N LIST)
:PROPERTIES:
:ID:       3ef93ba7-f9c1-452f-b539-de9556455bdb
:END:

Retorna o N-ésimo elemento de LIST.

Os indices dos elementos começam com 0. Caso N seja maior que o tamanho de LIST "nil" será retornado.

#+begin_src emacs-lisp
  (nth 2 '(1 2 3 4))
#+end_src

#+RESULTS:
: 3

#+begin_src emacs-lisp
  (nth 100 '(1 2))
#+end_src

#+RESULTS:

*** Elementos depois do N-ésimo elemento (NTHCDR N LIST)
:PROPERTIES:
:ID:       03fd5be6-4923-4ee9-a003-e4afc25efa8d
:END:

Retorna os elementos depoi do N-ésimo elemento de LIST.

Os indices dos elementos começam com 0. Se N for 0 então retorna todos os elementos da lista, Se N for maior que o tamanho de LIST "nil" será retornado.

#+begin_src emacs-lisp
  (nthcdr 3 '(0 1 2 3 4 5 6 7))
#+end_src

#+RESULTS:
| 3 | 4 | 5 | 6 | 7 |

#+begin_src emacs-lisp
  (nthcdr 0 '(1 2 3))
#+end_src

#+RESULTS:
| 1 | 2 | 3 |

#+begin_src emacs-lisp
  (nthcdr 100 '(1 2))
#+end_src

#+RESULTS:

** Adicionar elementos
:PROPERTIES:
:ID:       b7529299-f5fe-4720-8638-505754740358
:END:

*** add-to-list
:PROPERTIES:
:ID:       cefd0948-6ffa-4493-8cd5-fd9463745284
:END:

Função *add-to-list symbol element &optional append compare-fn*.

Coloca ELEMENT na lista SYMBOL se o elemento não esta presente. Retorna a lista atualizada ou não.

#+begin_src emacs-lisp
  (let ((list '(1 2)))
    (add-to-list 'list 3))
#+end_src

#+RESULTS:
| 3 | 1 | 2 |

#+begin_src emacs-lisp
  (let ((list '(1 2)))
    (add-to-list 'list 1))
#+end_src

#+RESULTS:
| 1 | 2 |

Por padrão os elementos são colocados no inicio da lista. Caso o argumento "append" seja não nulo, eles são adicionados ao final.

#+begin_src emacs-lisp
  (let ((list '(1 2)))
    (add-to-list 'list 3 t))
#+end_src

#+RESULTS:
| 1 | 2 | 3 |

Utiliza o argumento "compare-fn" para encontrar os elementos existentes na lista. Por padrão esta função é o "equal"

"compare-fn" recebe dois argumentos, o elemento da lista e o a entrar.

#+begin_src emacs-lisp
  (let ((list '((1 2) (2 3))))
    (add-to-list 'list '(3 4) t #'(lambda (x y)
                                    (equal (car x) (car y)))))
#+end_src

#+RESULTS:
| 1 | 2 |
| 2 | 3 |
| 3 | 4 |

*** TODO add-to-ordered-list
:PROPERTIES:
:ID:       af2160b8-4c3b-4b53-8975-681fcd5848d0
:END:

Função: *add-to-ordered-list symbol element &optional order*

Coloca um elemento na lista. Os elementos são procurados utilizando a função "eq". Caso o elemento ja esteja na lista ele não será inserido. Retorna a lista atualizada ou não.

Os elementos são ordenados em ordem crescente do argumento ORDER.

#+begin_src emacs-lisp
  (let ((list '()))
      (add-to-ordered-list 'list 1 0)
      (add-to-ordered-list 'list 2 2)
      (add-to-ordered-list 'list 3)
      (add-to-ordered-list 'list 4))
#+end_src

#+RESULTS:
| 1 | 4 | 3 | 2 |

#+begin_src emacs-lisp
  (let ((list '(9 8)))
      (add-to-ordered-list 'list 1 0)
      (add-to-ordered-list 'list 2 3)
      (add-to-ordered-list 'list 3 2)
      (add-to-ordered-list 'list 4 1))
#+end_src

#+RESULTS:
| 1 | 4 | 3 | 2 | 9 | 8 |

* Estruturas
:PROPERTIES:
:ID:       31f7cd19-1442-4360-8e24-172393737b50
:END:

https://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures

* Hash Table
:PROPERTIES:
:ID:       c064d4a0-4a0d-4dfa-9bd5-bcb4d04cf990
:END:

https://www.gnu.org/software/emacs/manual/html_node/elisp/Hash-Tables.html

Hash table é um tipo de tabela de rápido acesso. Cada chave correspode a um valor. Algumas das suas caracteristicas são: Rapidade de acesso a valores guardados independente da quantidade de dados armazenados; Seus valores e chaves não estão em uma ordem específica;

Elisp provê um tipo para "hash table" junto com uma série de funções pra operar com este tipo de dado. Eles apresentam uma forma especial de representação gráfica

#+begin_src emacs-lisp
  (make-hash-table)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8 data ())

** Criando Hash tables
:PROPERTIES:
:ID:       9c99981a-1e5b-4615-9fcf-82b44a3213bc
:END:

A principal função parar criar "hash tables" é (make-hash-table), ela apresenta alguns parametros que podem ser alterados tornando as tabelas mais expecíficas para cada oportunidade.

*** Argumento :test
:PROPERTIES:
:ID:       3f80d21a-a45b-4cc7-9cf9-f48a28172d2e
:END:

Este tipo especifica o método utilizado para comparar chaves a fim de verificar se encontrou o valor procurado.

O valor padrão é "eql". Outros valores que podem ser colocados são: "eq" e "equal".

#+begin_src emacs-lisp
  (make-hash-table :test 'eql)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8 data ())

#+begin_src emacs-lisp
  (make-hash-table :test 'eq)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8 data ())

#+begin_src emacs-lisp
  (make-hash-table :test 'equal)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data ())


*** Argumento :weakness
:PROPERTIES:
:ID:       89416869-2328-4bb1-9cff-d9f8ebe1ae4b
:END:

Esse argumento verifica se as chaves e os valores na tabela são preservados do coletor de lixo do sistema. 

O valor deve ser: "nil", "key", "value", "key-or-value", "key-and-value". 

Se o valor for "key" então a tabela não previne suas chaves de serem coletadas; Se uma chave for coletada a associação correspondente é removida da tabela.

#+begin_src emacs-lisp
  (make-hash-table :weakness 'key)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql weakness key rehash-size 1.5 rehash-threshold 0.8 data ())

Se o valor for "value" então a tabela não previne seus valores de serem coletados; Se um valor é coletado a associação correspondente é removida.

#+begin_src emacs-lisp
  (make-hash-table :weakness 'value)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql weakness value rehash-size 1.5 rehash-threshold 0.8 data ())

Se o valor for "key-and-value" então tanto a chave quanto o valor devem estar carregados para preservar a associação, portanto nem a chave nem o valor é preservado de serem coletados.

#+begin_src emacs-lisp
  (make-hash-table :weakness 'key-and-value)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql weakness key-and-value rehash-size 1.5 rehash-threshold 0.8 data ())

Se o valor for "key-or-value" então tanto a chave quando o valor podem preservar a associação, portanto a associação só é removida caso a chave e o valor sejam coletados.

#+begin_src emacs-lisp
  (make-hash-table :weakness 'key-or-value)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql weakness key-or-value rehash-size 1.5 rehash-threshold 0.8 data ())

O valor padrão é "nil". Com este argumento todas as chaves e valores são preservados.

#+begin_src emacs-lisp
  (make-hash-table :weakness 'nil)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8 data ())

** Manipulando Dados
:PROPERTIES:
:ID:       c787cce8-6d79-4446-908f-3b8efceb9013
:END:

Qualquer objeto LISP pode ser usado como *chave*, no entanto é preciso que o argumento "test" da criação da tabela seja apropriado.

Qualquer objeto LISP pode ser usado como *valor*.

*** Colocar valores (puthash)
:PROPERTIES:
:ID:       e8c21956-9d0e-4e2f-815d-424777dfefc2
:END:

*puthash key value table*, coloca na TABLE o valor VALUE associada com a chave KEY.

#+begin_src emacs-lisp
  (let ((table (make-hash-table)))
    (puthash '3 2 table)
    (puthash "string" 2 table)
    (puthash '(a 2) 2 table)
    table)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8 data (3 2 "string" 2 (a 2) 2))

*** Acessar valores (gethash)
:PROPERTIES:
:ID:       8ac3422d-b81f-4f27-b574-f021cabc48bb
:END:

*gethash key table &optional default*, procura por KEY em TABLE e retorna o valor encontrado. Se nenhum valor for encontrado DEFAULT será retornado. Por padrão DEFAULT é "nil".

#+begin_src emacs-lisp
  (let ((table (make-hash-table :test 'equal)))
    (puthash '3 2 table)
    (puthash "string" 6 table)
    (puthash '(a 2) 9 table)

    (gethash "string" table))
#+end_src

#+RESULTS:
: 6

*** Remover valores (remhash)
:PROPERTIES:
:ID:       6f4c0770-906a-42b1-b358-d29b6b4254f3
:END:

*remhash key table*, remove KEY de TABLE

#+begin_src emacs-lisp
  (let ((table (make-hash-table :test 'equal)))
    (puthash '3 2 table)
    (puthash "string" 6 table)
    (puthash '(a 2) 9 table)

    (remhash "string" table)
    table)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data (3 2 (a 2) 9))

#+begin_src emacs-lisp
  (let ((table (make-hash-table :test 'equal)))
    (puthash '3 2 table)
    (puthash "string" 6 table)
    (puthash '(a 2) 9 table)

    (remhash 'chave-inexistente table)
    table)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data (3 2 "string" 6 (a 2) 9))

*** Limpar tabela (clrhash)
:PROPERTIES:
:ID:       bb72550c-6fc1-4b44-9b78-a6c4ef48628a
:END:

*clrhash table*, limpa TABLE de todos os valores presenters nela.

#+begin_src emacs-lisp
  (let ((table (make-hash-table :test 'equal)))
    (puthash '3 2 table)
    (puthash "string" 6 table)
    (puthash '(a 2) 9 table)

    (clrhash table)
    table)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data ())

*** Mapear função (maphash)
:PROPERTIES:
:ID:       d01ac337-b060-4da3-aa5c-0a9e9bbe2e09
:END:

*maphash function table*, executa FUNCTION em todos os valores de TABLE. Function deve ser uma função que aceita dois argumentos a *chave* e o *valor*

#+begin_src emacs-lisp
  (let ((table (make-hash-table :test 'equal))
        (res '()))
    (puthash 1 2 table)
    (puthash 3 4 table)
    (puthash 5 6 table)

    (maphash #'(lambda (key value) 
                 (setq res (cons (cons key value) res))) 
             table)
    res)
#+end_src

#+RESULTS:
: ((5 . 6) (3 . 4) (1 . 2))

