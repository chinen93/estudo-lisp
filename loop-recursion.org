#+TITLE:        Loop and Recursion
#+AUTHOR:       Pedro Chinen
#+EMAIL:        ph.u.chinen@gmail.com
#+DATE-CREATED: [2018-01-21 Sun]
#+DATE-UPDATED: [2018-02-06 Tue]


* References
https://www.gnu.org/software/emacs/manual/html_node/eintr/Loops-_0026-Recursion.html


* RECURSION
https://www.gnu.org/software/emacs/manual/html_node/eintr/Recursion.html#Recursion

Recursão é um estilo de programação no qual uma função chama ela
mesma com outros parametros para com o intuito de fazer um
loop. É muito importante que os parametros das chamdas da função
sejam diferentes umas das outras de forma a levar o programa a
parar. Caso contrário ele ficará executando as mesmas intruções
sem fim.

Toda recursão tem uma mesma estrutura:
- Uma condição base, na qual quando ela é satisfeita a recursão para.
- Um passo, que é um argumento diferente do atual indo em direção a condição base.


O exemplo abaixo usa recursão para imprimir todos os elementos de uma
lista. A condição base é: "caso o argumento seja uma lista"; e o passo
é: "Chame a função recursivamente passando o resto da lista como
parâmetro".

#+begin_src emacs-lisp
  (setq animals '(gazelle giraffe lion tiger))
       
  (defun print-elements-recursively (list)
    "Print each element of LIST on a line of its own.
       Uses recursion."
    (when list                            ; do-again-test
      (print (car list))                  ; body
      (print-elements-recursively         ; recursive call
       (cdr list))))                      ; next-step-expression

  (print-elements-recursively animals)
#+end_src

Outro exemplo de função recursiva no qual o caso base é: "Se o
argumento for o número 1, retorno 1"; e o passo: "Chame a função
recursivamente usando como parâmetro o argumento - 1".

#+begin_src emacs-lisp
  (defun triangle-recursively (number)
    "Return the sum of the numbers 1 through NUMBER inclusive.
       Uses recursion."
    (if (= number 1)                    ; do-again-test
        1                               ; then-part
      (+ number                         ; else-part
         (triangle-recursively          ; recursive call
          (1- number)))))               ; next-step-expression

  (triangle-recursively 7)
#+end_src

#+RESULTS:
: 28

** Padrões de Recursão
:PROPERTIES:
:ID:       1c19f61f-82b0-4407-ae48-9b00ebeca745
:END:

Estes padrões de programação será utilizados em cima de listas. Elas
não precisam ser necessáriamente feitas em cima de listas, mas LISP é
projetado para trabalhar com listas, tornando essas recursões mais
simples.

*** Todo Elemento
:PROPERTIES:
:ID:       135028fc-bcc0-4a26-b809-477bbfca56ef
:END:

Neste padrão, a ação da recursão é realizada em todos os elementos. 

Segue uma construção básica:
- Veja se a lista esta vazia, retorne nil
- Aja sobre o primeiro elemento da lista, e faça a recursão para o
  resto da lista.

#+begin_src emacs-lisp
  (defun square-each (numbers-list)
    "Square each of a NUMBERS LIST, recursively."
    (if (not numbers-list)                ; do-again-test
        nil
      (cons
       (* (car numbers-list) (car numbers-list))
       (square-each (cdr numbers-list))))) ; next-step-expression

  (square-each '(1 2 3))
#+end_src

*** Acumulação de Chamadas Recursivas
:PROPERTIES:
:ID:       8c07bb52-6daa-46ae-81ed-fbe6ade897e3
:END:

A ação é realizado em todos os elementos da lista. Porem neste caso o
resultado da ação é acumulado com a chamada recursiva.

A construção é:
- Verifique se a lista esta vazia, retorne zero ou uma constante.
- Aja sobre o primeiro elemento, combine com o retorno da chamada
  recursiva para o resto da lista.

#+begin_src emacs-lisp
  (defun add-elements (numbers-list)
    "Add the elements of NUMBERS-LIST together."
    (if (not numbers-list)
        0
      (+ (car numbers-list) (add-elements (cdr numbers-list)))))

  (add-elements '(1 2 3 4))
#+end_src

#+RESULTS:
: 10

*** Guarde Elementos Pertinentes
:PROPERTIES:
:ID:       988b0af7-47bf-465a-acfc-4fefd763be4c
:END:

Neste padrão, todos os elementos são testados e apenas aqueles que
passarem neste teste serão usados como parte do resultado.

Construção:
- Verifique se a lista esta vazia, retorne nil
- Se o primeiro elemento passa no teste, aja sobre o elemento e
  combine o resultado com a chamada recursiva para o resto da lista.
- Se o primeiro elemento não passa no teste, não faça nada com este
  elemento e simplesmente retorne a chamada recursvida para o resto da
  lista.

#+begin_src emacs-lisp
  (defun keep-three-letter-words (word-list)
    "Keep three letter words in WORD-LIST."
    (cond
     ;; First do-again-test: stop-condition
     ((not word-list) nil)
     
     ;; Second do-again-test: when to act
     ((eq 3 (length (symbol-name (car word-list))))
      ;; combine acted-on element with recursive call on shorter list
      (cons (car word-list) (keep-three-letter-words (cdr word-list))))
     
     ;; Third do-again-test: when to skip element;
     ;;   recursively call shorter list with next-step expression
     (t (keep-three-letter-words (cdr word-list)))))

  (keep-three-letter-words '(one two three four five six))
#+end_src

* WHILE
https://www.gnu.org/software/emacs/manual/html_node/eintr/while.html#while

#+begin_src emacs-lisp
  (while 'test 'body)
#+end_src

Testa se TEST returna um valor não nulo. Executando BODY e repetindo.

A ordem da execução é TEST, BODY, TEST, BODY e assim por diante. Até
que TEST retorne nulo.

#+begin_src emacs-lisp
  (setq animals '(gazelle giraffe lion tiger))

  (defun print-elements-of-list (list)
    "Print each element of LIST on a line of its own."
    (while list
      (print (car list))
      (setq list (cdr list))))

  (print-elements-of-list animals)
#+end_src

No exemplo acima, é definido um conjunto de elementos em uma lista. E
criado a função print-elements-of-list. No corpo da função é utilizado
a estrutura WHILE. 

Como a variavel LIST é sempre alterada chega uma hora em que ela é
nil. Quando isso acontece a estrutura WHILE termina.

** Teste
:PROPERTIES:
:ID:       ae8278e6-a71f-44bf-ba4f-cea19ef85c36
:END:

O teste pode ser qualquer expressão de teste (<, >, =, equal, null,
etc). É preciso verificar qual tipo de expressão deverá ser utilizada
e como fazer com que essa condição seja satisfeita.

#+begin_src emacs-lisp
  (defun triangle (number-of-rows)    ; Version with
                                      ; incrementing counter.
    "Add up the number of pebbles in a triangle.
  The first row has one pebble, the second row two pebbles,
  the third row three pebbles, and so on.
  The argument is NUMBER-OF-ROWS."
    (let ((total 0)
          (row-number 1))
      (while (<= row-number number-of-rows)
        (setq total (+ total row-number))
        (setq row-number (1+ row-number)))
      total))

  (triangle 7)
#+end_src

#+RESULTS:
: 28

Neste exemplo, usamos uma comparação entre números para terminar a
estrutura WHILE.

* DOLIST
https://www.gnu.org/software/emacs/manual/html_node/eintr/dolist.html#dolist

* Loop
https://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility




